package markdown

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/adil-chbada/extract-cli/internal/config"
)

// formatFileSize formats file size in human readable format
func formatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

// getFileSize returns the size of a file, or -1 if error
func getFileSize(filePath string) int64 {
	info, err := os.Stat(filePath)
	if err != nil {
		return -1
	}
	return info.Size()
}

// WriteMarkdown writes a list of files to a markdown file
func WriteMarkdown(outputPath, title string, files []string, cfg *config.Config) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create markdown file: %w", err)
	}
	defer file.Close()

	// Sort files for consistent output
	sort.Strings(files)

	// Write header
	fmt.Fprintf(file, "# %s\n\n", title)

	// Calculate total size
	totalSize := int64(0)
	for _, filePath := range files {
		fileSize := getFileSize(filepath.Join(cfg.ProjectPath, filePath))
		if fileSize >= 0 {
			totalSize += fileSize
		}
	}
	
	// Write metadata
	fmt.Fprintf(file, "**Project:** %s  \n", getProjectName(cfg))
	fmt.Fprintf(file, "**Generated:** %s  \n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Fprintf(file, "**Total Files:** %d  \n", len(files))
	fmt.Fprintf(file, "**Total Size:** %s  \n\n", formatFileSize(totalSize))

	if len(files) == 0 {
		fmt.Fprintf(file, "*No files found matching the criteria.*\n")
		return nil
	}

	// Group files by directory for better organization
	groups := groupFilesByDirectory(files)

	// Write table of contents if there are multiple groups
	if len(groups) > 1 {
		fmt.Fprintf(file, "## Table of Contents\n\n")
		for _, dir := range getSortedDirectories(groups) {
			anchor := strings.ReplaceAll(strings.ToLower(dir), "/", "-")
			if dir == "." {
				fmt.Fprintf(file, "- [Root Directory](#root-directory)\n")
			} else {
				fmt.Fprintf(file, "- [%s](#%s)\n", dir, anchor)
			}
		}
		fmt.Fprintf(file, "\n")
	}

	// Write files grouped by directory
	for _, dir := range getSortedDirectories(groups) {
		dirFiles := groups[dir]
		
		// Calculate directory size
		dirSize := int64(0)
		for _, filePath := range dirFiles {
			fileSize := getFileSize(filepath.Join(cfg.ProjectPath, filePath))
			if fileSize >= 0 {
				dirSize += fileSize
			}
		}

		if dir == "." {
			fmt.Fprintf(file, "## Root Directory\n\n")
		} else {
			fmt.Fprintf(file, "## %s\n\n", dir)
		}

		fmt.Fprintf(file, "**Files in this directory:** %d  \n", len(dirFiles))
		fmt.Fprintf(file, "**Directory size:** %s\n\n", formatFileSize(dirSize))

		for _, filePath := range dirFiles {
			filename := filepath.Base(filePath)
			
			// Get file size
			fileSize := getFileSize(filepath.Join(cfg.ProjectPath, filePath))
			sizeStr := "unknown"
			if fileSize >= 0 {
				sizeStr = formatFileSize(fileSize)
			}
			
			fmt.Fprintf(file, "- `%s` **(%s)**", filename, sizeStr)

			// Add file extension info
			ext := filepath.Ext(filename)
			if ext != "" {
				fmt.Fprintf(file, " *(%s)*", strings.TrimPrefix(ext, "."))
			}

			// Add relative path if different from filename
			if filePath != filename {
				fmt.Fprintf(file, "  \n  üìÅ `%s`", filePath)
			}

			fmt.Fprintf(file, "\n")
		}
		fmt.Fprintf(file, "\n")
	}

	// Write summary footer
	fmt.Fprintf(file, "---\n\n")
	fmt.Fprintf(file, "**Summary:**\n")
	fmt.Fprintf(file, "- Total files listed: %d\n", len(files))
	fmt.Fprintf(file, "- Total size: %s\n", formatFileSize(totalSize))
	fmt.Fprintf(file, "- Directories covered: %d\n", len(groups))
	fmt.Fprintf(file, "- Generated by extract-cli\n")

	return nil
}

// groupFilesByDirectory groups files by their directory
func groupFilesByDirectory(files []string) map[string][]string {
	groups := make(map[string][]string)

	for _, file := range files {
		dir := filepath.Dir(file)
		if dir == "." || dir == "" {
			dir = "."
		}
		groups[dir] = append(groups[dir], file)
	}

	return groups
}

// getSortedDirectories returns directory names sorted with root first
func getSortedDirectories(groups map[string][]string) []string {
	var dirs []string
	for dir := range groups {
		dirs = append(dirs, dir)
	}

	sort.Slice(dirs, func(i, j int) bool {
		// Root directory comes first
		if dirs[i] == "." {
			return true
		}
		if dirs[j] == "." {
			return false
		}
		// Then sort alphabetically
		return dirs[i] < dirs[j]
	})

	return dirs
}

// getProjectName extracts project name from config or path
func getProjectName(cfg *config.Config) string {
	if cfg.ProjectName != "" {
		return cfg.ProjectName
	}

	// Extract from project path
	return filepath.Base(cfg.ProjectPath)
}